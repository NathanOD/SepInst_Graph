# Code partially taken from detectron2/modeling/roi_heads/roi_mask_head.py
from typing import List
import torch
import torch.nn.functional as F

from detectron2.layers import cat
from detectron2.structures import Instances


def dice_loss(pred_mask_logits: torch.Tensor, gt_masks: torch.Tensor):
    """
    Compute the Dice Loss.
    
    Args:
        pred_mask_logits (Tensor): Predicted mask logits of shape (B, H, W).
        gt_masks (Tensor): Ground truth masks of shape (B, H, W).

    Returns:
        Tensor: Dice loss.
    """
    smooth = 1.0  # for numerical stability
    pred_masks = pred_mask_logits.sigmoid()
    
    intersection = (pred_masks * gt_masks).sum(dim=(1, 2))
    union = pred_masks.sum(dim=(1, 2)) + gt_masks.sum(dim=(1, 2))
    
    dice = (2. * intersection + smooth) / (union + smooth)
    dice_loss = 1 - dice
    return dice_loss.mean()


@torch.jit.unused
def mask_loss(pred_mask_logits: torch.Tensor, instances: List[Instances], depth=False, use_dice_loss=False):
    """
    Compute the mask prediction loss defined in the Mask R-CNN paper.

    Args:
        pred_mask_logits (Tensor): A tensor of shape (B, C, Hmask, Wmask) or (B, 1, Hmask, Wmask)
            for class-specific or class-agnostic, where B is the total number of predicted masks
            in all images, C is the number of foreground classes, and Hmask, Wmask are the height
            and width of the mask predictions. The values are logits.
        instances (list[Instances]): A list of N Instances, where N is the number of images
            in the batch. These instances are in 1:1
            correspondence with the pred_mask_logits. The ground-truth labels (class, box, mask,
            ...) associated with each instance are stored in fields.
        vis_period (int): the period (in steps) to dump visualization.

    Returns:
        mask_loss (Tensor): A scalar tensor containing the loss.
    """
    cls_agnostic_mask = pred_mask_logits.size(1) == 1
    total_num_masks = pred_mask_logits.size(0)
    mask_side_len = pred_mask_logits.size(2)
    assert pred_mask_logits.size(2) == pred_mask_logits.size(3), "Mask prediction must be square!"

    gt_classes = []
    gt_masks = []
    for instances_per_image in instances:
        if len(instances_per_image) == 0:
            continue
        if not cls_agnostic_mask:
            gt_classes_per_image = instances_per_image.gt_classes.to(dtype=torch.int64)
            gt_classes.append(gt_classes_per_image)

        gt_masks_per_image = instances_per_image.gt_masks.crop_and_resize(
            instances_per_image.proposal_boxes.tensor, mask_side_len
        ).to(device=pred_mask_logits.device)
        # A tensor of shape (N, M, M), N=#instances in the image; M=mask_side_len
        gt_masks.append(gt_masks_per_image)

    if len(gt_masks) == 0:
        return pred_mask_logits.sum() * 0

    gt_masks = cat(gt_masks, dim=0)

    if cls_agnostic_mask:
        pred_mask_logits = pred_mask_logits[:, 0]
    else:
        indices = torch.arange(total_num_masks)
        gt_classes = cat(gt_classes, dim=0)
        pred_mask_logits = pred_mask_logits[indices, gt_classes]

    if gt_masks.dtype == torch.bool:
        gt_masks_bool = gt_masks
    else:
        # Here we allow gt_masks to be float as well (depend on the implementation of rasterize())
        gt_masks_bool = gt_masks > 0.5
    gt_masks = gt_masks.to(dtype=torch.float32)

    # Log the training accuracy (using gt classes and sigmoid(0.0) == 0.5 threshold)
    mask_incorrect = (pred_mask_logits > 0.0) != gt_masks_bool
    mask_accuracy = 1 - (mask_incorrect.sum().item() / max(mask_incorrect.numel(), 1.0))

    type = "rgbd" if depth else "rgb"

    metrics = {f"{type}_accuracy": mask_accuracy}

    losses = {f"loss_mask_{type}": F.binary_cross_entropy_with_logits(pred_mask_logits, gt_masks, reduction="mean")}
    
    if use_dice_loss:
        losses[f"loss_dice_{type}"] = dice_loss(pred_mask_logits, gt_masks)

    return losses, metrics